import json
import logging
import os
import shlex
import shutil
import subprocess
from dataclasses import dataclass
from pathlib import Path
from uuid import uuid4

import docker
from simple_parsing import ArgumentParser

from cybergym.task.gen_task import generate_task
from cybergym.task.types import TaskConfig, TaskDifficulty
from cybergym.utils import save_json

ENVS = ["OPENAI_API_KEY", "ANTHROPIC_API_KEY", "DOCKER_HOST"]
ENIGMA_IMAGE = "sweagent/enigma:latest"
SCRIPT_DIR = Path(__file__).parent.absolute()

# Setup logger
logger = logging.getLogger(__name__)


class EnigmaError(Exception):
    """Custom exception for Enigma errors"""

    pass


class EnigmaTimeoutError(EnigmaError):
    """Custom exception for Enigma timeout errors"""

    pass


@dataclass
class EnigmaArgs:
    model: str
    """Model to use for generation"""

    log_dir: Path
    """Directory to save the logs"""

    tmp_dir: Path
    """Directory to save the temporary files"""

    repo: Path = SCRIPT_DIR / "enigma-repo"
    """Path to the enigma repo"""

    enigma_python: Path = None
    """Path to the enigma python executable"""

    cost_limit: float = 2.0
    """Cost limit for the Enigma task in Dollars"""

    silent: bool = False
    """If true, suppresses the output of the Enigma agent"""

    remove_tmp: bool = True
    """if true, remove the tmp directory after running the agent"""

    timeout: int = 3600
    """Timeout for the task in seconds"""

    container_name: str = None
    """Name of the container, if not provided will be generated by uuid4"""


@dataclass
class TaskArgs:
    task_id: str
    """ID of the task to generate"""

    data_dir: Path
    """Directory containing the data files"""

    server: str
    """Server address for the task"""

    difficulty: TaskDifficulty = TaskDifficulty.level1
    """Difficulty level of the task"""


def init_empty_git_repo(repo_path: Path):
    """
    Initialize an empty git repository at the specified path.
    """
    subprocess.check_call(  # noqa: S603
        [
            "/bin/bash",
            "-c",
            "git init && "
            "echo '*' > .gitignore && echo '!/.gitignore' >> .gitignore && "
            "git add .gitignore && git commit -m 'Initial commit'",
        ],
        cwd=repo_path,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )


def validate_output(log_dir: Path):
    traj_jsons = list(log_dir.glob("trajectories/**/pwn_CyberGym.traj"))
    if not traj_jsons:
        logger.error(f"No traj json found in {log_dir}")
        return False
    return True


def run_enigma(
    python_executable: Path,
    log_dir: Path,
    input_dir: Path,
    repo: Path,
    model: str,
    cost_limit: float,
    container_name: str,
    silent: bool = False,
    timeout: int = 3600,
):
    repo = repo.absolute()
    input_dir = input_dir.absolute()
    log_dir = log_dir.absolute()

    # Define the repository path for the challenge
    chall_path = input_dir

    # Use the specified config file
    config_file = SCRIPT_DIR / "config/ctf_pwn.yaml"

    # Prepare the challenge.json path
    chall_json_path = chall_path / "challenge.json"

    # Prepare and run the command
    cmd = [
        # "/usr/bin/timeout", "--preserve-status", "-k", "30s", str(timeout),
        str(python_executable), str(repo / "run.py"),
        "--model_name", model,
        "--ctf",
        "--container_name", container_name,
        "--image_name", ENIGMA_IMAGE,
        "--data_path", str(chall_json_path),
        "--repo_path", str(chall_path),
        "--config_file", str(config_file),
        "--per_instance_cost_limit", str(cost_limit),
    ]  # fmt: skip

    logger.info(f"Running Enigma with command: {shlex.join(cmd)}")

    # Set up environment variables
    env = {
        "CYBERGYM_HOOK_REPO_NAME": "cybergym",
        "CYBERGYM_HOOK_INIT_DOCKER_NETWORK": "0",
        "CYBERGYM_HOOK_MAX_OUTPUT_TOKENS": "2048"
    }
    for env_var in ENVS:
        if os.getenv(env_var) is not None:
            env[env_var] = os.getenv(env_var)

    # Run the command and stream the output
    try:
        subprocess.run(  # noqa: S603
            cmd,
            cwd=log_dir,
            env=env,
            stdout=subprocess.DEVNULL if silent else None,
            stderr=subprocess.DEVNULL if silent else None,
            timeout=timeout,
        )
    except subprocess.TimeoutExpired:
        raise EnigmaTimeoutError(f"Enigma task timed out after {timeout} seconds") from None
    except Exception as e:
        logger.error(f"Error running Enigma: {e}")
    finally:
        try:
            client = docker.from_env()
            container = client.containers.get(container_name)
            container.remove(force=True)
        except docker.errors.NotFound:
            pass


def run_with_configs(enigma_args: EnigmaArgs, task_args: TaskArgs):
    if not enigma_args.enigma_python:
        enigma_args.enigma_python = enigma_args.repo / "venv/bin/python"

    enigma_args.tmp_dir.mkdir(parents=True, exist_ok=True)
    enigma_args.log_dir.mkdir(parents=True, exist_ok=True)

    agent_id = uuid4().hex
    sub_dir = task_args.task_id.replace(":", "_") + "-" + agent_id

    # 1. prepare the challenge inputs

    # 1.1. generate the task
    tmp_input_dir = enigma_args.tmp_dir / sub_dir
    tmp_input_dir.mkdir(parents=True)

    task_config = TaskConfig(
        task_id=task_args.task_id,
        out_dir=tmp_input_dir,
        data_dir=task_args.data_dir,
        server=task_args.server,
        difficulty=task_args.difficulty,
        agent_id=agent_id,
        with_flag=True,
    )
    task = generate_task(task_config)

    task_files = [file for file in tmp_input_dir.glob("**/*") if file.is_file()]

    # 1.2. copy the challenge.json file to the tmp directory
    shutil.copy(
        SCRIPT_DIR / "challenge_template/challenge.json",
        tmp_input_dir,
    )

    # mock a empty git repo
    init_empty_git_repo(tmp_input_dir)

    # 1.3. add all the task files to the json, TODO: or use a dist.tar.gz?
    with open(tmp_input_dir / "challenge.json") as f:
        chall_info = json.load(f)
        chall_info["files"] = [str(file.relative_to(tmp_input_dir)) for file in task_files]

    with open(tmp_input_dir / "challenge.json", "w") as f:
        json.dump(chall_info, f, indent=2)

    # 2. prepare the log directory
    log_dir = enigma_args.log_dir / sub_dir
    log_dir.mkdir()
    logger.info(f"Creating log directory: {log_dir}")

    # 2.1. save the task info to the log
    save_json(
        {
            "agent": f"enigma:{enigma_args.model}",
            "task": task,
            "agent_args": enigma_args,
            "task_args": task_args,
        },
        log_dir / "args.json",
        indent=2,
    )

    logger.info(f"Saving task info to: {log_dir / 'task.json'}")

    # 3. run the enigma agent
    run_enigma(
        python_executable=enigma_args.enigma_python,
        log_dir=log_dir,
        input_dir=tmp_input_dir,
        repo=enigma_args.repo,
        model=enigma_args.model,
        cost_limit=enigma_args.cost_limit,
        silent=enigma_args.silent,
        timeout=enigma_args.timeout,
        container_name=enigma_args.container_name or f"enigma-{agent_id}",
    )

    # 4. remove the tmp directory
    if enigma_args.remove_tmp:
        shutil.rmtree(tmp_input_dir, ignore_errors=True)
        logger.info(f"Removing temporary directory: {tmp_input_dir}")

    # 5. validate the output
    is_valid = validate_output(log_dir)

    return agent_id if is_valid else None


def main(raw_args=None):
    parser = ArgumentParser()
    parser.add_arguments(EnigmaArgs, dest="enigma_args")
    parser.add_arguments(TaskArgs, dest="task_args")

    args = parser.parse_args(raw_args)

    run_with_configs(args.enigma_args, args.task_args)


if __name__ == "__main__":
    logger.setLevel(logging.INFO)
    formatter = logging.Formatter("[%(levelname)s] %(message)s")
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    main()
